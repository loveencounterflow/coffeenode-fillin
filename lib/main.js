// Generated by CoffeeScript 1.7.1
(function() {
  var BAP, TEXT, TRM, TYPES, alert, badge, debug, echo, help, info, log, rpr, warn, whisper,
    __slice = [].slice;

  BAP = require('coffeenode-bitsnpieces');

  TYPES = require('coffeenode-types');

  TEXT = require('coffeenode-text');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'FILLIN';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  this.walk_containers_crumbs_and_values = function(value, handler) {

    /* Given a `value` and a `handler` with the signature `( error, container, crumbs, value )`, this method
    will call `handler null, container, crumbs, value` for each 'primitive' sub-value ('leaf value') that is
    found inside of `value`, where `container` is the list or POD that contains `value`, and `crumbs` is a
    (possibly empty) list of names that, when transformed as `'/' + crumbs.join '/'`, spells out the locator
    where `value` was found. When `crumbs` is not empty, its last element will be the index (in case of a
    list) or the name (in case of a POD) where `value` was found.
    
    When iteration is done, the method will make one additional call with all arguments set to `null`;
    consumers are able to detect that iteration has terminated by testing for `crumbs is null`.
    
    An **example** will show better what's happening:
    
    ````coffee
    d =
      meaningless: [
        42
        43
        { foo: 1, bar: 2, nested: [ 'a', 'b', ] }
        45 ]
      deep:
        down:
          in:
            a:
              drawer:   'a pen'
              cupboard: 'a pot'
              box:      'a pill'
    
    BAP.walk_containers_crumbs_and_values d, ( error, container, crumbs, value ) ->
      throw error if error?
      if crumbs is null
        log 'over'
        return
      locator           = '/' + crumbs.join '/'
       * in case you want to mutate values in a container, use:
      [ head..., key, ] = crumbs
      log "#{locator}:", rpr value
    ````
    
    Output:
    
    ````
    /meaningless/0: 42
    /meaningless/1: 43
    /meaningless/2/foo: 1
    /meaningless/2/bar: 2
    /meaningless/2/nested/0: 'a'
    /meaningless/2/nested/1: 'b'
    /meaningless/3: 45
    /deep/down/in/a/drawer: 'a pen'
    /deep/down/in/a/cupboard: 'a pot'
    /deep/down/in/a/box: 'a pill'
    over
    ````
    
    As can be seen, there are no callbacks made for values that are lists or PODs, only for primitive values
    (or objects that are no lists and no PODs). Keep in mind that some JavaScript objects may *look* like PODs
    or lists, but are really something different. As the primary use case for this method is analysis of
    nested configurations read from a JSON file, such complexities have not been considered in the design of
    this method.
    
    You may pass a single primitive value to `@walk_containers_crumbs_and_values`; this will result in a
    callback where `crumbs` is an empty list and `value` is the value you passed in.
    
    **Caveats:**
    
    Because of the way iteration happens in CoffeeScript and JavaScript, it's not a good idea to modify the
    containers you're currently iterating over.
    [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in#Description)
    has the following to say:
    
    > If a property is modified in one iteration and then visited at a later time, its value in the loop is
    > its value at that later time. A property that is deleted before it has been visited will not be visited
    > later. Properties added to the object over which iteration is occurring may either be visited or omitted
    > from iteration. **In general it is best not to add, modify or remove properties from the object during
    > iteration, other than the property currently being visited.** There is no guarantee whether or not an
    > added property will be visited, whether a modified property (other than the current one) will be visited
    > before or after it is modified, or whether a deleted property will be visited before it is deleted.
    
    **Therefore, if deeper modifications are necessary, you may want to do those on a copy of the object
    you're inspecting, or else keep a log of intended changes and execute those changes when iteration has
    stopped.**
    
    The `crumbs` list in the callback is always the same object, so in case you want to use the values
    elsewhere—and especially when used in an asynchronous fashion—you may want to make a copy of that list.
    
    The method currently makes no effort to respect bad naming choices in any way, which means that you may
    get faulty or troublesome locators in case names are empty, consist of single or double periods, or
    contain slashes, asterisks or other meta-characters.
     */
    var container, crumbs;
    container = null;
    crumbs = [];
    this._walk_containers_crumbs_and_values(container, crumbs, value, handler);
    return null;
  };

  this._walk_containers_crumbs_and_values = function(container, crumbs, value, handler) {

    /* ( used by @[`walk_containers_crumbs_and_values`](#this.walk_containers_crumbs_and_values)) */
    TYPES = require('coffeenode-types');
    if (TYPES.isa_pod(value)) {
      return this._walk_pod_crumbs_and_values(container, crumbs, value, handler);
    } else if (TYPES.isa_list(value)) {
      return this._walk_list_crumbs_and_values(container, crumbs, value, handler);
    }
    handler(null, container, crumbs, value);
    if (crumbs.length === 0) {
      handler(null, null, null, null);
    }
    return null;
  };

  this._walk_list_crumbs_and_values = function(container, crumbs, list, handler) {

    /* ( used by @[`walk_containers_crumbs_and_values`](#this.walk_containers_crumbs_and_values)) */
    var idx, value, _i, _len;
    for (idx = _i = 0, _len = list.length; _i < _len; idx = ++_i) {
      value = list[idx];
      crumbs.push(idx);
      this._walk_containers_crumbs_and_values(list, crumbs, value, handler);
      crumbs.pop();
    }
    if (crumbs.length === 0) {
      handler(null, null, null, null);
    }
    return null;
  };

  this._walk_pod_crumbs_and_values = function(container, crumbs, pod, handler) {

    /* ( used by @[`walk_containers_crumbs_and_values`](#this.walk_containers_crumbs_and_values)) */
    var name, value;
    for (name in pod) {
      value = pod[name];
      crumbs.push(name);
      this._walk_containers_crumbs_and_values(pod, crumbs, value, handler);
      crumbs.pop();
    }
    if (crumbs.length === 0) {
      return handler(null, null, null, null);
    }
  };

  this.container_and_facet_from_locator = function(container, locator) {

    /* The inverse to @[`walk_containers_crumbs_and_values`](#this.walk_containers_crumbs_and_values), this
    method uses a `locator` to drill down into `container`, recursively applying the 'crumbs' (parts) of
    the `locator` until all of the locator has been consumed; it will then return a triplet `[ sub_container,
    key, value, ]`.
    
    The locator must either be the string `/` (which denotes the `container` itself) or else a string that
    starts with but does not end with a `/`.
     */
    var crumbs;
    rpr = (require('util')).inspect;
    if (locator === '/') {
      return [null, null, container];
    } else {
      if (!/^\/.*?[^\/]$/.test(locator)) {
        throw new Error("locator must start with but not end with a slash, got " + (rpr(locator)));
      }
      (crumbs = locator.split('/')).shift();
    }
    return this._container_and_facet_from_crumbs(container, locator, crumbs, 0);
  };

  this.container_and_facet_from_crumbs = function(container, crumbs) {

    /* Same as @[`container_and_facet_from_locator`](#this.container_and_facet_from_locator), but accepting
    a list of crumbs instead of a locator.
     */
    var locator;
    if (crumbs === null || crumbs.length === 0) {
      return [null, null, container];
    }
    locator = '/' + crumbs.join('/');
    return this._container_and_facet_from_crumbs(container, locator, crumbs, 0);
  };

  this._container_and_facet_from_crumbs = function(container, locator, crumbs, idx) {

    /* (used by @[`container_and_facet_from_locator`](#this.container_and_facet_from_locator) and
    @[`container_and_facet_from_crumbs`](#this.container_and_facet_from_crumbs))
     */
    var error, key, value;
    rpr = (require('util')).inspect;
    key = crumbs[idx];
    if (key == null) {
      throw new Error("unable to get crumb " + idx + " from locator #rpr locator");
    }
    try {
      value = container[key];
    } catch (_error) {
      error = _error;
      value = void 0;
    }
    if (value === void 0) {
      throw new Error("unable to resolve key " + (rpr(key)) + " in locator " + (rpr(locator)));
    }
    if (idx === crumbs.length - 1) {
      return [container, key, value];
    }
    return this._container_and_facet_from_crumbs(value, locator, crumbs, idx + 1);
    return null;
  };

  this.set = function(container, locator_or_crumbs, value) {
    var key, method_name, old_value, _ref;
    TYPES = require('coffeenode-types');
    if (TYPES.isa_list(locator_or_crumbs)) {
      method_name = 'container_and_facet_from_crumbs';
    } else {
      method_name = 'container_and_facet_from_locator';
    }
    _ref = this[method_name](container, locator_or_crumbs), container = _ref[0], key = _ref[1], old_value = _ref[2];
    container[key] = value;
    return [container, key, old_value];
  };

  this.new_method = function(matcher_hint) {
    var R, matcher;
    matcher = TYPES.isa_regex(matcher_hint) ? matcher : this.new_matcher(matcher_hint);
    R = (function(_this) {
      return function(template, data, other_matcher) {
        return _this.fill_in(template, data, other_matcher != null ? other_matcher : matcher);
      };
    })(this);
    return R.bind(this);
  };


  /* TAINT use options argument */

  this.new_matcher = function(options) {
    var R, activator, closer, escaper, forbidden, opener, _ref, _ref1, _ref2, _ref3, _ref4;
    if (options == null) {
      options = {};
    }
    activator = (_ref = options['activator']) != null ? _ref : '$';
    opener = (_ref1 = options['opener']) != null ? _ref1 : '{';
    closer = (_ref2 = options['closer']) != null ? _ref2 : '}';
    escaper = (_ref3 = options['escaper']) != null ? _ref3 : '\\';
    forbidden = (_ref4 = options['forbidden']) != null ? _ref4 : "{}<>()|*+.,;:!\"'$%&/=?`´#";
    forbidden = TEXT.list_of_unique_chrs(activator + opener + closer + escaper + forbidden);
    forbidden = (BAP.escape_regex(forbidden.join(''))) + '\\s';
    activator = BAP.escape_regex(activator);
    opener = BAP.escape_regex(opener);
    closer = BAP.escape_regex(closer);
    escaper = BAP.escape_regex(escaper);
    R = RegExp("(^|" + escaper + escaper + "|[^" + escaper + "])(" + activator + "(?:([^" + forbidden + "]+)|" + opener + "(" + escaper + activator + "|" + escaper + opener + "|" + escaper + closer + "|[^" + activator + opener + closer + "]+)" + closer + "))((?:\\\\\\$|[^" + activator + "])*)$");
    R['remover'] = RegExp("" + escaper + "(" + activator + "|" + opener + "|" + closer + "|" + escaper + ")", "g");
    return R;
  };

  this.fill_in = function(template_or_container, data, matcher) {
    if (TYPES.isa_text(template_or_container)) {
      return this.fill_in_template(template_or_container, data, matcher);
    }
    return this.fill_in_container(template_or_container, data, matcher);
  };

  this.fill_in_template = function(template, data, matcher) {
    return this._fill_in_template.apply(this, [template].concat(__slice.call(this._get_data_and_matcher(data, matcher))));
  };

  this._fill_in_template = function(template, data, matcher) {
    var R, has_matched, result, seen, _ref;
    seen = {};
    R = template;
    seen[R] = 1;
    while (true) {
      _ref = this._fill_in_template_once(R, data, matcher), has_matched = _ref[0], R = _ref[1];
      if (!has_matched) {
        return R.replace(matcher.remover, '$1');
      }
      if (seen[R] != null) {
        seen = __slice.call((function() {
            var _results;
            _results = [];
            for (result in seen) {
              _results.push(rpr(result));
            }
            return _results;
          })()).concat([rpr(R)]);
        seen = seen.join('\n');
        throw new Error("detected circular references in " + (rpr(template)) + ":\n" + seen);
      }
      seen[R] = 1;
    }
  };

  this._fill_in_template_once = function(template, data, matcher) {
    var R, container, head, key, markup, name, new_value, position, tail, _ref, _ref1;
    R = template;
    _ref = this._analyze_template(template, matcher), position = _ref[0], head = _ref[1], markup = _ref[2], name = _ref[3], tail = _ref[4];
    if (position == null) {
      return [false, template];
    }
    if (name[0] !== '/') {
      name = '/' + name;
    }
    _ref1 = this.container_and_facet_from_locator(data, name), container = _ref1[0], key = _ref1[1], new_value = _ref1[2];
    R = head + (TYPES.isa_text(new_value) ? new_value : rpr(new_value)) + tail;
    return [true, R];
  };

  this._analyze_template = function(template, matcher) {
    var bare, bracketed, head, ignored, markup, match, name, position, prefix, tail;
    match = template.match(matcher);
    if (match == null) {
      return [];
    }
    ignored = match[0], prefix = match[1], markup = match[2], bare = match[3], bracketed = match[4], tail = match[5];
    position = match.index + prefix.length;
    name = bare != null ? bare : bracketed;
    head = template.slice(0, position);
    return [position, head, markup, name, tail];
  };

  this.fill_in_container = function(container, data, matcher) {
    var change_count, error, errors, fill_in, m, _ref;
    _ref = this._get_data_and_matcher(data, matcher), data = _ref[0], matcher = _ref[1];
    if (data == null) {
      data = container;
    }
    errors = null;
    fill_in = (function(_this) {
      return function(matcher, sub_container, crumbs, old_value) {
        var does_match, key, locator, message, new_value;
        does_match = matcher.test(old_value);
        new_value = _this._fill_in_template(old_value, data, matcher);
        if (does_match) {
          if (old_value === new_value) {
            locator = '/' + crumbs.join('/');
            message = "* unable to resolve " + locator + ": " + (rpr(old_value)) + " (circular reference?)";
            return (errors = errors != null ? errors : {})[message] = 1;
          } else {
            key = crumbs[crumbs.length - 1];
            sub_container[key] = new_value;
            return change_count += 1;
          }
        }
      };
    })(this);
    while (true) {
      change_count = 0;
      this.walk_containers_crumbs_and_values(container, (function(_this) {
        return function(error, sub_container, crumbs, old_value) {
          if (error != null) {
            throw error;
          }
          if (crumbs === null) {
            return;
          }
          if (!TYPES.isa_text(old_value)) {
            return;
          }
          return fill_in(matcher, sub_container, crumbs, old_value);
        };
      })(this));
      if (change_count === 0) {
        break;
      }
    }
    if (errors != null) {
      error = new Error('\nerrors have occurred:\n' + (((function() {
        var _results;
        _results = [];
        for (m in errors) {
          _results.push(m);
        }
        return _results;
      })()).sort().join('\n')) + '\n');
      throw error;
    }
    return container;
  };

  this._get_data_and_matcher = function(data, matcher) {
    if (matcher != null) {
      return [data, matcher];
    }
    return [data, this.default_matcher];
  };

  this.default_matcher = this.new_matcher();

}).call(this);
