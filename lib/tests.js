// Generated by CoffeeScript 1.7.1
(function() {
  var FILLIN, TEXT, TRM, TYPES, alert, assert, badge, d, debug, echo, help, info, log, rpr, warn, whisper;

  TYPES = require('coffeenode-types');

  TEXT = require('coffeenode-text');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'FILLIN/tests';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  assert = require('assert');

  FILLIN = require('./main');

  this.test_argument_retrieval = function() {
    var data, expected, handler, matcher, parameters, probes, result, _i, _len, _ref, _results;
    handler = function() {};
    data = {
      'foo': 'bar'
    };
    matcher = /.*/;
    probes = [[[handler], [FILLIN.default_matcher, null, handler]], [[matcher, data], [matcher, data, null]], [[matcher, handler], [matcher, null, handler]], [[data], [FILLIN.default_matcher, data, null]]];
    assert.notEqual(FILLIN.default_matcher, void 0);
    _results = [];
    for (_i = 0, _len = probes.length; _i < _len; _i++) {
      _ref = probes[_i], parameters = _ref[0], expected = _ref[1];
      result = FILLIN._get_matcher_data_and_handler.apply(FILLIN, parameters);
      _results.push(assert.deepEqual(result, expected));
    }
    return _results;
  };

  this.test_standard_syntax_1 = function() {
    var data, expected, result, template, templates_and_expectations, _i, _len, _ref, _results;
    templates_and_expectations = [['helo name', 'helo name'], ['helo ${name}', 'helo Jim'], ['helo \\$name', 'helo \\$name'], ['helo \\${name}', 'helo \\${name}'], ['helo ${{name}}', 'helo ${{name}}'], ['helo $name!', 'helo Jim!'], ['helo +name!', 'helo +name!'], ['helo !+name!', 'helo !+name!']];
    data = {
      'name': 'Jim'
    };
    _results = [];
    for (_i = 0, _len = templates_and_expectations.length; _i < _len; _i++) {
      _ref = templates_and_expectations[_i], template = _ref[0], expected = _ref[1];
      result = FILLIN.fill_in(template, data);
      log(TRM.green('test_standard_syntax_1'), TRM.grey(template), TRM.gold(result));
      _results.push(assert.equal(result, expected));
    }
    return _results;
  };

  this.test_custom_syntax_1 = function() {
    var data, expected, matcher, result, template, templates_and_expectations, _i, _len, _ref, _results;
    templates_and_expectations = [['helo name', 'helo name'], ['helo ${name}', 'helo ${name}'], ['helo \\$name', 'helo \\$name'], ['helo \\${name}', 'helo \\${name}'], ['helo ${{name}}', 'helo ${{name}}'], ['helo $name!', 'helo $name!'], ['helo +name!', 'helo Jim!'], ['helo !+name!', 'helo !+name!'], ['helo +(name)!', 'helo Jim!']];
    data = {
      'name': 'Jim'
    };
    matcher = FILLIN.new_matcher('+', '(', ')', '!');
    _results = [];
    for (_i = 0, _len = templates_and_expectations.length; _i < _len; _i++) {
      _ref = templates_and_expectations[_i], template = _ref[0], expected = _ref[1];
      result = FILLIN.fill_in(template, matcher, data);
      log(TRM.green('test_custom_syntax_1'), TRM.grey(template), TRM.gold(result));
      _results.push(assert.equal(result, expected));
    }
    return _results;
  };

  this.test_custom_syntax_2 = function() {
    var data, expected, matcher, result, template, templates_and_expectations, _i, _len, _ref, _results;
    templates_and_expectations = [['helo name', 'helo name'], ['helo ${name}', 'helo ${name}'], ['helo \\$name', 'helo \\$name'], ['helo \\${name}', 'helo \\${name}'], ['helo ${{name}}', 'helo ${{name}}'], ['helo $name!', 'helo $name!'], ['helo +name!', 'helo Jim!'], ['helo !+name!', 'helo !+name!'], ['helo +(name)!', 'helo Jim!']];
    data = {
      'name': 'Jim'
    };
    matcher = FILLIN.new_matcher('+', '(', ')', '!');
    _results = [];
    for (_i = 0, _len = templates_and_expectations.length; _i < _len; _i++) {
      _ref = templates_and_expectations[_i], template = _ref[0], expected = _ref[1];
      result = FILLIN.fill_in(template, matcher, function(error, key) {
        if (error != null) {
          throw error;
        }
        if (key === 'name') {
          return 'Jim';
        } else {
          return '???';
        }
      });
      log(TRM.green('test_custom_syntax_1'), TRM.grey(template), TRM.gold(result));
      _results.push(assert.equal(result, expected));
    }
    return _results;
  };

  this.main = function() {
    this.test_argument_retrieval();
    this.test_standard_syntax_1();
    this.test_custom_syntax_1();
    return this.test_custom_syntax_2();
  };

  d = {
    meaningless: [
      42, 43, {
        foo: 1,
        bar: 2,
        nested: ['a', 'b']
      }, 45
    ],
    deep: {
      down: {
        "in": {
          a: {
            drawer: '${/my-things/pen}',
            cupboard: '${/my-things/pot}',
            box: '${${locations/for-things}/variable}'
          }
        }
      }
    },
    'my-things': {
      pen: 'a pen',
      pot: 'a pot',
      pill: 'a pill',
      variable: '${/my-things/pill}'
    },
    locations: {
      'for-things': '/my-things'
    },
    ping1: '${/ping4}',
    ping2: '${/ping3}',
    ping3: '${/ping2}',
    ping4: '${/ping1}',
    pong: '${/ping1}'
  };

  this.main();

}).call(this);
